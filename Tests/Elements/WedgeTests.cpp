// #define DISABLE_WEDGE_TESTS

#ifndef DISABLE_WEDGE_TESTS

#include "WedgeTests.h"
#include <Eigen/Eigenvalues>

TEST_F(WedgeTest, FF_ExactValues) {

    auto ff = wedge->FF(0.0, 0.0, -1.0);
    EXPECT_EQ(ff.size(), 6);
    
    for (int i = 0; i < 6; i++) {
        EXPECT_TRUE(std::isfinite(std::abs(ff[i])))
            << "FF[" << i << "] should be finite";
    }
    
    auto ff_center = wedge->FF(1.0/3.0, 1.0/3.0, -1.0);
    for (int i = 0; i < 6; i++) {
        EXPECT_TRUE(std::isfinite(std::abs(ff_center[i])))
            << "FF[" << i << "] at centroid should be finite";
    }
}

TEST_F(WedgeTest, B_ExactAllValues) {

    Eigen::MatrixXcd B = wedge->B(0.0, 0.0, 0.0);
    
    for (int i = 0; i < 6; i++) {
        for (int j = 0; j < 18; j++) {
            EXPECT_TRUE(std::isfinite(B(i, j).real()))
                << "B(" << i << "," << j << ") should be finite";
            EXPECT_NEAR(B(i, j).imag(), 0.0, 1e-12)
                << "B(" << i << "," << j << ") should not have imaginary part";
        }
    }
    
    EXPECT_EQ(B.rows(), 6) << "B should have 6 rows";
    EXPECT_EQ(B.cols(), 18) << "B should have 18 columns";
    
    double norm = B.norm();
    EXPECT_GT(norm, 0.0) << "Norm B should be positive";
}

TEST_F(WedgeTest, localK_ExactAllMatrixValues) {

    double E = 210e9;
    double nu = 0.3;
    wedge->set_constants(E, nu, 7850.0);
    
    double factor = E / ((1.0 + nu) * (1.0 - 2.0 * nu));
    wedge->D = Eigen::MatrixXd::Zero(6, 6);
    wedge->D(0, 0) = wedge->D(1, 1) = wedge->D(2, 2) = factor * (1.0 - nu);
    wedge->D(0, 1) = wedge->D(0, 2) = wedge->D(1, 0) = wedge->D(1, 2) = wedge->D(2, 0) = wedge->D(2, 1) = factor * nu;
    wedge->D(3, 3) = wedge->D(4, 4) = wedge->D(5, 5) = factor * (1.0 - 2.0 * nu) / 2.0;
    
    Eigen::MatrixXcd K = wedge->localK();
    
    const double K_values[18][18] = {
        {373931623.931624, 169968919.96892, 74361402.4864025, -479099893.162393, -166782002.719503, 9560751.74825172, -128538995.726496, -236894182.206682, 103043657.731158, 46741452.9914529, 63738344.9883449, 19121503.4965035, -175280448.717949, -20183809.2463092, -196526563.714064, -58426816.2393162, -43554535.7420357, -103043657.731158},
        {169968919.96892, 373931623.931624, 74361402.4864025, -236894182.206682, -128538995.726496, 103043657.731158, -166782002.719503, -479099893.162393, 9560751.74825172, 63738344.9883449, 46741452.9914529, 19121503.4965035, -43554535.7420357, -58426816.2393162, -103043657.731158, -20183809.2463092, -175280448.717949, -196526563.714064},
        {74361402.4864025, 74361402.4864025, 373931623.931624, -83922154.2346543, 56302204.7397047, 46741452.991453, 56302204.7397047, -83922154.2346542, 46741452.991453, 65862956.4879565, 65862956.4879565, -186965811.965812, -196526563.714064, -56302204.7397047, -233707264.957265, -56302204.7397047, -196526563.714064, -233707264.957265},
        {-479099893.162393, -236894182.206682, -83922154.2346543, 1595052083.33333, 121279906.436156, -597546984.265734, 286291399.572649, 583028805.685056, -346842827.311577, -549212072.649573, -230520347.707848, 270887966.200466, 368088942.307692, -27797000.4532504, 223615360.33411, -192808493.589744, 258317348.161098, 346842827.311577},
        {-166782002.719503, -128538995.726496, 56302204.7397047, 121279906.436156, 660223023.504274, -130132454.351204, 396062993.719244, 286291399.572649, -253359921.328671, -183778894.716395, -315504807.692308, 130663607.226107, 18944452.5382025, -99325587.6068376, 130132454.351204, 164834442.178192, 40898771.3675214, -120571702.602953},
        {9560751.74825172, 103043657.731158, 46741452.991453, -597546984.265734, -130132454.351204, 1137375356.12536, -253359921.328671, -346842827.311577, 451834045.584045, 270887966.200466, 177405060.21756, -373931623.931624, 36649548.3682984, 130132454.351204, -576477920.22792, 253359921.328671, -214054608.585859, -358351139.601139},
        {-128538995.726496, -166782002.719503, 56302204.7397047, 286291399.572649, 396062993.719244, -253359921.328671, 660223023.504273, 121279906.436156, -130132454.351204, -315504807.692308, -183778894.716395, 130663607.226107, 40898771.3675214, 164834442.178192, -120571702.602953, -99325587.6068376, 18944452.5382025, 130132454.351204},
        {-236894182.206682, -479099893.162393, -83922154.2346543, 583028805.685056, 286291399.572649, -346842827.311577, 121279906.436156, 1595052083.33333, -597546984.265734, -230520347.707848, -549212072.649572, 270887966.200466, 258317348.161098, -192808493.589744, 346842827.311577, -27797000.4532504, 368088942.307692, 223615360.33411},
        {103043657.731158, 9560751.74825172, 46741452.9914531, -346842827.311577, -253359921.328671, 451834045.584045, -130132454.351204, -597546984.265734, 1137375356.12536, 177405060.21756, 270887966.200466, -373931623.931624, -214054608.585859, 253359921.328671, -358351139.601139, 130132454.351204, 36649548.3682984, -576477920.22792},
        {46741452.9914529, 63738344.9883449, 65862956.4879565, -549212072.649573, -183778894.716395, 270887966.200466, -315504807.692308, -230520347.707848, 177405060.21756, 584268162.393162, 286822552.447552, -159345862.470862, -432358440.17094, -96669823.2323232, -83922154.2346542, 35056089.7435898, -190152729.215229, -177405060.21756},
        {63738344.9883449, 46741452.9914529, 65862956.4879565, -230520347.707848, -315504807.692308, 177405060.21756, -183778894.716395, -549212072.649573, 270887966.200466, 286822552.447552, 584268162.393162, -159345862.470862, -190152729.215229, 35056089.7435898, -177405060.21756, -96669823.2323232, -432358440.17094, -83922154.2346542},
        {19121503.4965035, 19121503.4965035, -186965811.965812, 270887966.200466, 130663607.226107, -373931623.931624, 130663607.226107, 270887966.200466, -373931623.931624, -159345862.470862, -159345862.470862, 467414529.91453, 9560751.74825176, -130663607.226107, 93482905.982906, -130663607.226107, 9560751.74825176, 93482905.982906},
        {-175280448.717949, -43554535.7420357, -196526563.714064, 368088942.307692, 18944452.5382026, 36649548.3682983, 40898771.3675214, 258317348.161098, -214054608.585859, -432358440.17094, -190152729.215229, 9560751.74825177, 940671741.452991, -112427358.521109, 337282075.563326, -134381677.350427, 302580087.736338, 214054608.585859},
        {-20183809.2463092, -58426816.2393162, -56302204.7397047, -27797000.4532504, -99325587.6068376, 130132454.351204, 164834442.178192, -192808493.589744, 253359921.328671, -96669823.2323232, 35056089.7435898, -130663607.226107, -112427358.521109, 473257211.538461, -130132454.351204, 209097181.753432, -134381677.350427, 120571702.602953},
        {-196526563.714064, -103043657.731158, -233707264.957265, 223615360.33411, 130132454.351204, -576477920.22792, -120571702.602953, 346842827.311577, -358351139.601139, -83922154.2346542, -177405060.21756, 93482905.982906, 337282075.563326, -130132454.351204, 950409544.159544, 120571702.602953, 214054608.585859, 264868233.618234},
        {-58426816.2393162, -20183809.2463092, -56302204.7397047, -192808493.589744, 164834442.178192, 253359921.328671, -99325587.6068376, -27797000.4532504, 130132454.351204, 35056089.7435898, -96669823.2323232, -130663607.226107, -134381677.350427, 209097181.753432, 120571702.602953, 473257211.538462, -112427358.521109, -130132454.351204},
        {-43554535.7420357, -175280448.717949, -196526563.714064, 258317348.161098, 40898771.3675214, -214054608.585859, 18944452.5382026, 368088942.307692, 36649548.3682983, -190152729.215229, -432358440.17094, 9560751.74825177, 302580087.736338, -134381677.350427, 214054608.585859, -112427358.521109, 940671741.452991, 337282075.563326},
        {-103043657.731158, -196526563.714064, -233707264.957265, 346842827.311577, -120571702.602953, -358351139.601139, 130132454.351204, 223615360.33411, -576477920.22792, -177405060.21756, -83922154.2346542, 93482905.982906, 214054608.585859, 120571702.602953, 264868233.618234, -130132454.351204, 337282075.563325, 950409544.159544}
    };
    
    for (int i = 0; i < 18; i++) {
        for (int j = 0; j < 18; j++) {
            const double expected = K_values[i][j];
            EXPECT_NEAR(K(i, j).real(), expected, std::abs(expected) * 1e-6)
                << "K(" << i << "," << j << ") should be equal to " << expected;
            EXPECT_NEAR(K(i, j).imag(), 0.0, 1e-12)
                << "K(" << i << "," << j << ") should not have imaginary part";
        }
    }
    
    for (int i = 0; i < 18; i++) {
        for (int j = 0; j < 18; j++) {
            EXPECT_NEAR(K(i, j).real(), K(j, i).real(), std::abs(K(i, j).real()) * 1e-10)
                << "K is not symmetric at position (" << i << "," << j << ")";
        }
    }
    
    for (int i = 0; i < 18; i++) {
        EXPECT_GT(K(i, i).real(), 0.0)
            << "Diagonal element K(" << i << "," << i << ") should be positive";
    }
    
    Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> solver(K.real());
    for (int i = 0; i < 18; i++) {
        EXPECT_GT(solver.eigenvalues()(i), 0.0)
            << "Eigenvalue " << i << " should be positive";
    }
}

TEST_F(WedgeTest, localF_ExactAllValues) {

    double pressure_value = 1000.0;
    wedge->set_load(PRESSURE, 0, {pressure_value, 0, 0, 0, 0, 0});
    
    std::vector<double> F = wedge->localF();
    
    EXPECT_EQ(F.size(), 18) << "Vector size F should be 18";
    
    double total_force = 0.0;
    for (int i = 0; i < 18; i++) {
        total_force += std::abs(F[i]);
    }
    EXPECT_GT(total_force, 0.0) << "Total load should be positive";
    
    const double F_expected[18] = {
        0.0, 0.0, -125.0, 0.0, 0.0, -125.0, 0.0, 0.0, -125.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
    };
    
    for (int i = 0; i < 18; i++) {
        const double expected = F_expected[i];
        EXPECT_NEAR(F[i], expected, std::abs(expected) * 1e-6)
            << "F[" << i << "] should be equal to " << expected;
        EXPECT_TRUE(std::isfinite(F[i])) << "F[" << i << "] should be finite";
    }
}

TEST_F(WedgeTest, localC_ExactAllMatrixValues) {

    Eigen::MatrixXd C = wedge->localC();
    
    const double C_values[6][6] = {
        {0.000133959190672154, 0.000155392661179698, 0.000155392661179698, 6.69795953360768e-05, 7.76963305898491e-05, 7.76963305898491e-05},
        {0.000155392661179698, 0.000696587791495199, 0.000342935528120713, 7.76963305898491e-05, 0.000348293895747599, 0.000171467764060357},
        {0.000155392661179698, 0.000342935528120713, 0.000696587791495199, 7.76963305898491e-05, 0.000171467764060357, 0.000348293895747599},
        {6.69795953360768e-05, 7.76963305898491e-05, 7.76963305898491e-05, 0.000133959190672154, 0.000155392661179698, 0.000155392661179698},
        {7.76963305898491e-05, 0.000348293895747599, 0.000171467764060357, 0.000155392661179698, 0.000696587791495199, 0.000342935528120713},
        {7.76963305898491e-05, 0.000171467764060357, 0.000348293895747599, 0.000155392661179698, 0.000342935528120713, 0.000696587791495199}
    };
    
    for (int i = 0; i < 6; i++) {
        for (int j = 0; j < 6; j++) {
            const double expected = C_values[i][j];
            EXPECT_NEAR(C(i, j), expected, std::abs(expected) * 1e-10)
                << "C(" << i << "," << j << ") should be equal to " << expected;
        }
    }
    
    for (int i = 0; i < 6; i++) {
        for (int j = 0; j < 6; j++) {
            EXPECT_NEAR(C(i, j), C(j, i), 1e-12)
                << "C is not symmetric at position (" << i << "," << j << ")";
        }
    }
    
    for (int i = 0; i < 6; i++) {
        for (int j = 0; j < 6; j++) {
            EXPECT_GT(C(i, j), 0.0)
                << "C(" << i << "," << j << ") should be positive";
        }
    }
}

TEST_F(WedgeTest, localR_ExactAllValues) {

    std::vector<double> values(6, 1.0);
    std::vector<double> R = wedge->localR(values);
    
    const double expected = 0.08333333333333333;
    
    EXPECT_EQ(R.size(), 6) << "Vector size R should be 6";
    
    for (int i = 0; i < 6; i++) {
        EXPECT_NEAR(R[i], expected, std::abs(expected) * 1e-10)
            << "R[" << i << "] should be equal to " << expected;
        EXPECT_GT(R[i], 0.0) << "R[" << i << "] should be positive";
        EXPECT_TRUE(std::isfinite(R[i])) << "R[" << i << "] should be finite";
    }
    
    if (R.size() > 0) {
        double first_value = R[0];
        for (int i = 1; i < 6; i++) {
            EXPECT_NEAR(R[i], first_value, std::abs(first_value) * 1e-10)
                << "R[" << i << "] should be equal to R[0] = " << first_value;
        }
    }
}

TEST_F(WedgeTest, localM_ExactAllMatrixValues) {

    Eigen::MatrixXcd M = wedge->localM();
    
    const double expected_mass_per_node = 654.1666666666666;
    
    for (int i = 0; i < 18; i += 3) {
        EXPECT_NEAR(M(i, i).real(), expected_mass_per_node, 1e-6)
            << "M(" << i << "," << i << ") should be equal to " << expected_mass_per_node;
    }
    for (int i = 1; i < 18; i += 3) {
        EXPECT_NEAR(M(i, i).real(), expected_mass_per_node, 1e-6)
            << "M(" << i << "," << i << ") should be equal to " << expected_mass_per_node;
    }
    for (int i = 2; i < 18; i += 3) {
        EXPECT_NEAR(M(i, i).real(), expected_mass_per_node, 1e-6)
            << "M(" << i << "," << i << ") should be equal to " << expected_mass_per_node;
    }
    
    const double M_values[18][18] = {
        {1.05157964677641, 0.0, 0.0, 1.21983239026063, 0.0, 0.0, 1.21983239026063, 0.0, 0.0, 0.525789823388203, 0.0, 0.0, 0.609916195130315, 0.0, 0.0, 0.609916195130315, 0.0, 0.0},
        {0.0, 1.05157964677641, 0.0, 0.0, 1.21983239026063, 0.0, 0.0, 1.21983239026063, 0.0, 0.0, 0.525789823388203, 0.0, 0.0, 0.609916195130315, 0.0, 0.0, 0.609916195130315, 0.0},
        {0.0, 0.0, 1.05157964677641, 0.0, 0.0, 1.21983239026063, 0.0, 0.0, 1.21983239026063, 0.0, 0.0, 0.525789823388203, 0.0, 0.0, 0.609916195130315, 0.0, 0.0, 0.609916195130315},
        {1.21983239026063, 0.0, 0.0, 5.46821416323731, 0.0, 0.0, 2.6920438957476, 0.0, 0.0, 0.609916195130315, 0.0, 0.0, 2.73410708161865, 0.0, 0.0, 1.3460219478738, 0.0, 0.0},
        {0.0, 1.21983239026063, 0.0, 0.0, 5.46821416323731, 0.0, 0.0, 2.6920438957476, 0.0, 0.0, 0.609916195130315, 0.0, 0.0, 2.73410708161865, 0.0, 0.0, 1.3460219478738, 0.0},
        {0.0, 0.0, 1.21983239026063, 0.0, 0.0, 5.46821416323731, 0.0, 0.0, 2.6920438957476, 0.0, 0.0, 0.609916195130315, 0.0, 0.0, 2.73410708161865, 0.0, 0.0, 1.3460219478738},
        {1.21983239026063, 0.0, 0.0, 2.6920438957476, 0.0, 0.0, 5.46821416323731, 0.0, 0.0, 0.609916195130315, 0.0, 0.0, 1.3460219478738, 0.0, 0.0, 2.73410708161865, 0.0, 0.0},
        {0.0, 1.21983239026063, 0.0, 0.0, 2.6920438957476, 0.0, 0.0, 5.46821416323731, 0.0, 0.0, 0.609916195130315, 0.0, 0.0, 1.3460219478738, 0.0, 0.0, 2.73410708161865, 0.0},
        {0.0, 0.0, 1.21983239026063, 0.0, 0.0, 2.6920438957476, 0.0, 0.0, 5.46821416323731, 0.0, 0.0, 0.609916195130315, 0.0, 0.0, 1.3460219478738, 0.0, 0.0, 2.73410708161865},
        {0.525789823388203, 0.0, 0.0, 0.609916195130315, 0.0, 0.0, 0.609916195130315, 0.0, 0.0, 1.05157964677641, 0.0, 0.0, 1.21983239026063, 0.0, 0.0, 1.21983239026063, 0.0, 0.0},
        {0.0, 0.525789823388203, 0.0, 0.0, 0.609916195130315, 0.0, 0.0, 0.609916195130315, 0.0, 0.0, 1.05157964677641, 0.0, 0.0, 1.21983239026063, 0.0, 0.0, 1.21983239026063, 0.0},
        {0.0, 0.0, 0.525789823388203, 0.0, 0.0, 0.609916195130315, 0.0, 0.0, 0.609916195130315, 0.0, 0.0, 1.05157964677641, 0.0, 0.0, 1.21983239026063, 0.0, 0.0, 1.21983239026063},
        {0.609916195130315, 0.0, 0.0, 2.73410708161865, 0.0, 0.0, 1.3460219478738, 0.0, 0.0, 1.21983239026063, 0.0, 0.0, 5.46821416323731, 0.0, 0.0, 2.6920438957476, 0.0, 0.0},
        {0.0, 0.609916195130315, 0.0, 0.0, 2.73410708161865, 0.0, 0.0, 1.3460219478738, 0.0, 0.0, 1.21983239026063, 0.0, 0.0, 5.46821416323731, 0.0, 0.0, 2.6920438957476, 0.0},
        {0.0, 0.0, 0.609916195130315, 0.0, 0.0, 2.73410708161865, 0.0, 0.0, 1.3460219478738, 0.0, 0.0, 1.21983239026063, 0.0, 0.0, 5.46821416323731, 0.0, 0.0, 2.6920438957476},
        {0.609916195130315, 0.0, 0.0, 1.3460219478738, 0.0, 0.0, 2.73410708161865, 0.0, 0.0, 1.21983239026063, 0.0, 0.0, 2.6920438957476, 0.0, 0.0, 5.46821416323731, 0.0, 0.0},
        {0.0, 0.609916195130315, 0.0, 0.0, 1.3460219478738, 0.0, 0.0, 2.73410708161865, 0.0, 0.0, 1.21983239026063, 0.0, 0.0, 2.6920438957476, 0.0, 0.0, 5.46821416323731, 0.0},
        {0.0, 0.0, 0.609916195130315, 0.0, 0.0, 1.3460219478738, 0.0, 0.0, 2.73410708161865, 0.0, 0.0, 1.21983239026063, 0.0, 0.0, 2.6920438957476, 0.0, 0.0, 5.46821416323731}
    };
    
    for (int i = 0; i < 18; i++) {
        for (int j = 0; j < 18; j++) {
            const double expected = M_values[i][j];
            EXPECT_NEAR(M(i, j).real(), expected, std::abs(expected) * 1e-6)
                << "M(" << i << "," << j << ") should be equal to " << expected;
            EXPECT_NEAR(M(i, j).imag(), 0.0, 1e-12)
                << "M(" << i << "," << j << ") should not have imaginary part";
        }
    }
    
    for (int i = 0; i < 18; i++) {
        for (int j = 0; j < 18; j++) {
            EXPECT_NEAR(M(i, j).real(), M(j, i).real(), std::abs(M(i, j).real()) * 1e-10)
                << "M is not symmetric at position (" << i << "," << j << ")";
        }
    }
    
    for (int i = 0; i < 18; i++) {
        EXPECT_GT(M(i, i).real(), 0.0)
            << "Diagonal element M(" << i << "," << i << ") should be positive";
    }
}

TEST_F(WedgeTest, Volume_ExactVolumeCalculation) {

    double volume = wedge->Volume();
    const double expected = 0.5;
    EXPECT_NEAR(volume, expected, 1e-9) << "Volume should be equal to " << expected;
}

#endif
